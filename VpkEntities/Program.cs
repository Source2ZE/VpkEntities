using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Encodings.Web;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Tasks;
using SteamDatabase.ValvePak;
using ValveResourceFormat;
using ValveResourceFormat.ResourceTypes;
using ValveResourceFormat.Serialization.KeyValues;
using KVValueType = ValveKeyValue.KVValueType;

namespace VpkEntities;

internal static class Program
{
    internal static async Task Main(string[] args)
    {
        var version = typeof(Program).Assembly.GetName()
                                     .Version!;

        Console.Title = $"Vpk to Entities v{version.Major}.{version.Minor}";

        var header = $"// Generated by VpkEntities v{version.Major}.{version.Minor}\n// Made by Kyle 'Kxnrl' Frankiss.\n";

        string file;

        if (Debugger.IsAttached)
        {
#if true
            file = @"C:\App\Steam\SteamApps\workshop\content\730\3399001595\3399001595_dir.vpk";
#else
            file = @"C:\App\Steam\SteamApps\workshop\content\730\3387284574\3387284574.vpk";
#endif
        }
        else if (args.Length != 1)
        {
            ColoredConsole.Print(ConsoleColor.Red,      "Invalid File!");
            ColoredConsole.Print(ConsoleColor.DarkCyan, "Drag file or use VpkEntities.exe {{file path}}");
            ConsoleAction.EndContext();

            Environment.Exit(1);

            return;
        }
        else
        {
            file = args[0];
        }

        try
        {
            using var vpk = new Package();
            vpk.Read(file);

            var lump = new Dictionary<string, Dictionary<string, List<Entity>>>();

            // vpk reader does not support multi-threading
            foreach (var (name, entries) in vpk.Entries)
            {
                if (name.Equals("vpk"))
                {
                    foreach (var entry in entries)
                    {
                        ColoredConsole.Print(ConsoleColor.Cyan, $"Reading {entry.FileName} ...");

                        vpk.ReadEntry(entry, out var bin);

                        lump.Add(entry.FileName, ParseMapVpk(bin));
                    }
                }
            }

            var options = new JsonSerializerOptions
            {
                DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull,
                WriteIndented          = true,
                Encoder                = JavaScriptEncoder.UnsafeRelaxedJsonEscaping,
            };

            var vpkName = Path.GetFileNameWithoutExtension(file);
            var worker  = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Desktop), vpkName);
            Directory.CreateDirectory(worker);

            Console.WriteLine();

            // combined
            {
                var text = header + JsonSerializer.Serialize(lump, options);
                var path = Path.Combine(worker, $"{vpkName}_full.jsonc");
                await File.WriteAllTextAsync(path, text, new UTF8Encoding(false));
                ColoredConsole.Print(ConsoleColor.Green, $"Wrote {path} ...");
            }

            // children vpk
            await Parallel.ForEachAsync(lump,
                                        async (pair, ctx) =>
                                        {
                                            var cVpk  = pair.Key;
                                            var lumps = pair.Value;

                                            await Parallel.ForEachAsync(lumps,
                                                                        ctx,
                                                                        async (lumpPair, innerCtx) =>
                                                                        {
                                                                            var dir = Path.Combine(worker, cVpk);
                                                                            Directory.CreateDirectory(dir);

                                                                            var name   = lumpPair.Key;
                                                                            var entity = lumpPair.Value;

                                                                            var text = header
                                                                                + JsonSerializer
                                                                                    .Serialize(entity, options);

                                                                            var path = Path.Combine(dir, $"{name}.jsonc");

                                                                            await File.WriteAllTextAsync(path,
                                                                                text,
                                                                                new UTF8Encoding(false),
                                                                                innerCtx);

                                                                            ColoredConsole.Print(ConsoleColor.Green,
                                                                                $"Wrote {path} ...");
                                                                        });
                                        });
        }
        catch (Exception e)
        {
            Console.WriteLine("Error");
            Console.WriteLine(e.ToString());
        }

        ConsoleAction.EndContext();
    }

    private static Dictionary<string, List<Entity>> ParseMapVpk(byte[] bin)
    {
        using var memory = new MemoryStream(bin);

        using var vpk = new Package();
        vpk.SetFileName("map.vpk");
        vpk.Read(memory);

        var entities = new Dictionary<string, List<Entity>>();

        foreach (var (name, entries) in vpk.Entries)
        {
            if (name.Equals("vents_c"))
            {
                foreach (var vent in entries)
                {
                    try
                    {
                        ColoredConsole.Print(ConsoleColor.Cyan, $"  -> Parsing {vent.FileName} ...");

                        vpk.ReadEntry(vent, out var ventBytes);

                        var entityBlock = ParseLump(vent.FileName, vent.TypeName, ventBytes);
                        entities.Add(vent.FileName, entityBlock.ToList());
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine($"Failed to Open {vent.GetFullPath()}");
                        Console.WriteLine(e);
                        Console.WriteLine("");
                    }
                }
            }
        }

        return entities;
    }

    private static IEnumerable<Entity> ParseLump(string vent, string ext, byte[] ventBytes)
    {
        using var memory   = new MemoryStream(ventBytes);
        using var resource = new Resource();
        resource.FileName = $"{vent}.{ext}";
        resource.Read(memory);

        if (resource.DataBlock is EntityLump { } lump)
        {
            foreach (var entity in lump.GetEntities())
            {
                yield return new Entity(entity);
            }
        }
    }

    internal static string GetEntityProperty(this EntityLump.Entity entity, string property, string defaultVal)
        => entity.Properties
                 .SingleOrDefault(x => x.Key.Equals(property, StringComparison.OrdinalIgnoreCase))
                 .Value?.ToString()
           ?? defaultVal;

    internal static string? GetEntityProperty(this EntityLump.Entity entity, string property)
        => entity.Properties
                 .SingleOrDefault(x => x.Key.Equals(property, StringComparison.OrdinalIgnoreCase))
                 .Value?.ToString();

    internal static string GetEntityRequiredProperty(this EntityLump.Entity entity, string property)
        => entity.Properties
                 .SingleOrDefault(x => x.Key.Equals(property, StringComparison.OrdinalIgnoreCase))
                 .Value?.ToString()
           ?? throw new KeyNotFoundException($"{property} not found");
}

internal record Entity
{
    internal record Connection(
        [property: JsonPropertyName("output")] string Output,
        [property: JsonPropertyName("target")] string Target,
        [property: JsonPropertyName("input")]  string Input,
        [property: JsonPropertyName("param")]  string Param,
        [property: JsonPropertyName("delay")]  double Delay,
        [property: JsonPropertyName("limit")]  long   TimeToUse);

    [JsonPropertyName("classname")]
    public string Classname { get; }

    [JsonPropertyName("hammerUniqueId")]
    public string HammerUniqueId { get; }

    [JsonPropertyName("targetname")]
    public string? Targetname { get; }

    [JsonPropertyName("properties")]

    // ReSharper disable once MemberCanBePrivate.Global
    public Dictionary<string, object> Properties { get; }

    [JsonPropertyName("connections")]

    // ReSharper disable once MemberCanBePrivate.Global
    public List<Connection>? Connections { get; }

    public Entity(EntityLump.Entity entity)
    {
        Classname      = entity.GetEntityRequiredProperty("classname");
        HammerUniqueId = entity.GetEntityRequiredProperty("hammerUniqueId");
        Targetname     = entity.GetEntityProperty("targetname");

        Properties = [];

        foreach (var (key, value) in entity.Properties)
        {
            if (key.Equals("classname", StringComparison.OrdinalIgnoreCase)
                || key.Contains("targetname",     StringComparison.OrdinalIgnoreCase)
                || key.Contains("hammerUniqueId", StringComparison.OrdinalIgnoreCase))
            {
                continue;
            }

            if (value is KVObject kvObject)
            {
                if (kvObject.IsArray)
                {
                    var values = string.Join(' ', kvObject.Properties.Select(x => KVValueString(x.Value)));
                    Properties.Add(key, values);

                    Properties.Add($"{key} __RAW_ARRAY__ ({kvObject.Properties.First().Value.Type}[{kvObject.Count}])",
                                   kvObject.Properties
                                           .Select(x => x.Value.Value)
                                           .ToArray());
                }
                else
                {
                    Properties.Add($"{key} __RAW_OBJECT__ (Pair)",
                                   kvObject.Properties.ToDictionary(x => x.Key, x => KVValueString(x.Value)));
                }

                continue;
            }

            Properties.Add(key, value.ToString() ?? "<_null_>");
        }

        if (entity.Connections is not null)
        {
            Connections = [];

            foreach (var connection in entity.Connections)
            {
                long timesToFire;

                try
                {
                    timesToFire = connection.GetProperty<long>("m_nTimesToFire");
                }
                catch
                {
                    timesToFire = connection.GetProperty<int>("m_nTimesToFire");
                }

                var io = new Connection(connection.GetProperty<string>("m_outputName"),
                                        connection.GetProperty<string>("m_targetName"),
                                        connection.GetProperty<string>("m_inputName"),
                                        connection.GetProperty<string>("m_overrideParam"),
                                        Math.Round(connection.GetProperty<double>("m_flDelay"), 4),
                                        timesToFire);

                Connections.Add(io);
            }
        }
    }

    private static object? KVValueString(KVValue value)
        => value.Type switch
        {
            KVValueType.Collection or KVValueType.Array => ((KVObject) value.Value).Properties,
            KVValueType.String                          => (string) value.Value,
            KVValueType.Boolean => ((bool) value.Value).ToString()
                                                       .ToLower(),
            KVValueType.FloatingPoint => Convert.ToSingle(value.Value, CultureInfo.InvariantCulture)
                                                .ToString("#0.000000", CultureInfo.InvariantCulture),
            KVValueType.FloatingPoint64 => Convert.ToDouble(value.Value, CultureInfo.InvariantCulture)
                                                  .ToString("#0.000000", CultureInfo.InvariantCulture),
            KVValueType.Int64  => Convert.ToInt64(value.Value, CultureInfo.InvariantCulture),
            KVValueType.UInt64 => Convert.ToUInt64(value.Value, CultureInfo.InvariantCulture),
            KVValueType.Int32  => Convert.ToInt32(value.Value, CultureInfo.InvariantCulture),
            KVValueType.UInt32 => Convert.ToUInt32(value.Value, CultureInfo.InvariantCulture),
            KVValueType.Int16  => Convert.ToInt16(value.Value, CultureInfo.InvariantCulture),
            KVValueType.UInt16 => Convert.ToUInt16(value.Value, CultureInfo.InvariantCulture),
            KVValueType.Null   => "<_null_>",
            _                  => throw new NotSupportedException($"Not Support type {value.Type}"),
        };
}
